<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Section Six</title>

		<link rel="stylesheet" href="./dist/reset.css">
		<link rel="stylesheet" href="./dist/reveal.css">
		<link rel="stylesheet" href="./dist/theme/black.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="./plugin/highlight/monokai.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section data-markdown>
					# Section Six
					Selection
					---
					### Making Decisions
					* One of the major items when talking about computers and what they excel at is making decisions, and in fact is at the heart of computing.
					* We can talk about these decisions by looking at the choices we can make:
						* Choose whether to perform an operation.
						* Choose between possible outcomes.
						* Select from a variety of choices.
					* We typically think of these as yes/no, `true`/`false`, or *boolean* decisions.
					---
					### Decision Operators
					* Relational operators allow us to compare our options in order to arrive at the correct decision path.
					* **ALL** decisions must arrive at a clear `true` or `false` result. (*boolean expressions*).
					* We use *relational operators* to help us arrive at the result of a decision.
					* We also use *logical operators* to chain our decisions to add conditionals to our decisions.
					---
					### Relational Operators
					| Operator | Description |
					| --- | --- |
					| `<` | Less-Than |
					| `>` | Greater-Than |
					| `<=` | Less-Than or Equal-To |
					| `>=` | Greather-Than or Equal-To |
					| `==` | Equal-To |
					| `!=` | NOT Equal-To |
					---
					### Relational Operator Usage
					* The result of each of these operators is always a *boolean expression*. -- `true` or `false`
					* The results can be assigned to a variable. `bool` data type
					* If `x` is `10`, then:
							5 < 10;           // true
							5 > 10;           // false
							x == 10;          // true
							x != 8;           // true
							x == 8;           // false
							bool y = x <= 10; // true
							y == false;       // false
							y == (x >= 10);     // true
					---
					### Non-numerical Comparison
					* We can use *relational operators* on `char` datatypes and `string`s. However it is important to know how they work!
						* The ASCII value of the individual characters are compared.
								'A' < 'Z';        // true
								'z' > 'a';        // true
								'a' < 'Z';        // false
						* Strings are compared character by character.
								'Mary' < 'Mark'   // false
								'Zoe' < 'Cathy'   // true 
					---
					### Logical Operators
					| Operator | Description |
					| --- | --- |
					| `&&` | Logical AND |
					| `\|\|` | Logical OR |
					| `!` | NOT (Unary) |

					* Be careful when inputing *logical operators* making sure to include both symbols of the operators, not doing so creates BINARY operators not LOGICAL.
					---
					### Logical Operator Usage
					* We can use *logical operators* to combine with *relational operators* to increase the complexity of our resulting test condition.
					* If `x` is `8`, `y` is `12.2`, and `z` is `8`, then:
							3.4 < 9 || 9 < 0            // true
							3 == 3 && 3 > 12            // false
							9 < 4 || 0 > 3              // false
							9 > 4 && 3 != 0             // true
							x > 0 || x != z             // true
							y > 0 && y <= x             // false
							y < z && x >= z             // false
							bool a = z > 0 && z < 100   // true
					---
					### Logical Operator Notes
					* `!` has the highest precedence, followed by `&&`, and finally `||`.
					* Associativity flows from left-to-right, however if the value of an expression can be determined by examining the sub-expression on the left side of the operator then the right sub-expression will not evaluate.
							// Assume x and y are 5						
							false && x++;  // x == 5
							true || y++;   // y == 5
							
							true && x++;   // x == 6
							false || y++;  // y == 6
					---
					### Control Structures
					* When we want to make decisions we use *control structures*. Sometimes these are referred to as statements they aren't *actual* statements.
						* We refer to them as *control structures* in order to signify their importance in the structural control of the program.
					* We will examine several *control structures* in the course of this class:
						* `if`, `if-else` -- Selection
						* `while`, `do-while`, `for` -- Repetition
					---
					### `if` Control Structure
					* The `if` structure is the most basic form of *control structures*. The *syntax* is:
							if(conditional_statement)
								statement_to_be_executed_if_true;
					* **EXAMPLE**:
							int x;
							std::cout << "Enter a value for x: ";
							std::cin >> x;

							if( x < 0 ) // Check if x is less than 0.
								std::cout << "You entered a negative value.\n";
					---
					### `if` Control Structure
					* Sometimes we need to execute additional statements. We may add a *block* of code to the *body* of the `if` control structure to accomplish this.
					* **EXAMPLE**:
							int x;
							std::cout << "Enter a value for x: ";
							std::cin >> x;

							if( x < 0 ) {  // Check if x is less than 0.
								std::cout << "You entered a negative value.\n";
								x = 0;  // Ensure that we have non-negative value.
							} // End of code block, everything inside will be executed
					---
					### `if-else` Control Structure
					* Sometimes we also want to have a flow of execution that happens on the `false` outcome as well.
						* "If it's raining, wear a rain coat, otherwise wear a short sleeve shirt"
					* We can accomplish this with the `if-else` *control structure*. Syntax:
							if(conditional_statement)
								statement_to_be_executed_if_true;
							else
								statement_to_be_executed_if_false;
					---
					### `if-else` Example
						int x;
						std::cout << "Enter a value for x: ";
						std::cin >> x;

						if( x < 0 )  // Check if x is less than 0.
							std::cout << "You entered a negative value.\n";
						else
							std::cout << "You entered a positive value.\n";
					* Keep in mind you can have code *blocks* replacing the body of the `if` and `else`.
							if(conditional_statement) {
								statement_to_be_executed_if_true;
							}
							else {
								statement_to_be_executed_if_false;
							}
					---
					### `if-else` Tips & Tricks
					* Decisions are **ALWAYS** binary. Meaning that only one of the two statements can ever occur, never both.
					* The `else` part is always optional. Only use it if you need it.
					* **ALWAYS INDENT** the *body* of your control structures, it allows you to determine ownership of statements when reading the code.
					* It is recommended to always use blocks for the body of the if and else.
						* Will save time debugging if more code is added later.
					---
					### Nested Control Structures
					* We can add any legal C++ statement into our `if` structures that we like.
						* As part of the *body* of any *control structure* we can place another *control structure*. This is known as *nesting*, or *nested control structures*.
					* **EXAMPLE:**
							if(condition_1) {
								if(condition_2) {
									executed_1&2_true
								} else {
									executed_1_true_2_false
								}
								executed_when_1_true
							} else
								executed_when_1_false
					---
					### Selecting from Multiple Options
					* Sometimes we have a menu or decision where we want to differentiate between multiple options. We can do this by using an *if-else chain*.
					* **EXAMPLE:**
							// Assume door is an integer containing 1, 2, or 3:
							std::cout << "Behind door #" << door << ", you see a ";
							if(door == 1) {         // door #1
								std::cout << "new car!\n";
							}
							else if(door == 2) {    // door #2
								std::cout << "trip to Maui!\n";
							}
							else {                  // door #3
								std::cout << "goat!\n";
							}
					---
					### Checking Ranges
					* We can check if something falls within a range:
							if(grade >= 90 && grade <= 100)
								cout << "You earned an A!";
					* We can also check if it falls outside a range:
							if(grade <= 0 || grade >= 100)
								cout << "That is an invalid grade.";
					* Make sure you use *logical operators* we **CANNOT** write:
							if(0 <= grade <= 100) // DOESN'T WORK
					---
					### Error/Default Options
					* Sometimes we have the possibility of unexpected data. We can use a trailing `else` to take care of it:
							// Assume door is an integer containing a user-entered value:
							std::string result;
							if(door == 1)          // door #1
								result = "new car!\n";
							else if(door == 2)     // door #2
								result = "trip to Maui!\n";
							else if(door == 3)     // door #3
								result = "goat!\n";
							else {                  // non-existent door
								std::cout << door << " was not an option! GAME OVER!\n";
								exit(1);
							}
							cout << "Behind door #" << door << ", you see a " << result;
					---
					### Non-`bool` conditionals
					* C++ control structures do not strictly require *boolean expressions* in their conditionals.
						* Any non-zero value will evaluate as `true`, and zero will be `false`
						* **Be careful** with the *assignment operator*
								// This will print "8 is 4!" ... Why?
								int x = 8;
								// [...]
								std::cout << x;
								if( x = 4 ) {
									std::cout << " is 4!";
								}
					---
					### Ternary `if` Operator
					* The ternary `if` operator functions identical to a standard `if-else` control structure, but the syntax and use cases vary.
					* Ternary `if` should only be used on short bits of statements and should not detract from the readability of the code.
					* **SYNTAX/EXAMPLE**:
								conditional_statement ? statement_if_true : statement_if_false;
								x > 0 ? cout << "Positive" : cout << "Negative";
					---
					### Numerical Inaccuracy
					* Computers identify numbers in binary (base-2).
						* Integers are easily and quickly converted into binary, however conversions for Real Numbers is not as simple.
					* We also have nubmers that even with base-10 cannot be represented and are thus *irrational*.
						* Example: `π, e`
					* We also have numbers that can be represented in base-10 however cannot be represented properly.
						* Example: `0.1`, `0.3`
					* We are forced to *round* such numbers.
					---
					### Representing Real Numbers
					* When we convert base-10 decimal numbers into their base-2 representation we do so by a *deterministic* approach. Meaning that everytime we use `0.1` for example it will return the exact same value.
					* However, the values are being rounded thus the internal representation contains some *rounding errors*.
					* When using these numbers in mathematical calculations the errors compound and can eventually return differing results.
					---
					### Epsilon
					* Thus, testing a calculated floating point value for **equality** against another isn't guaranteed to produce correct results.
					* This leads us into how much rounding error is acceptable and how do we determine how much exists?
					* **Epsilon** - an arbitrarily small positive quantity in mathematical analysis.
						* Pick your epsilon value based upon the precision of your needed output. Typically 10-decimal places is sufficient.
					---
					### Using an Epsilon Comparison
					* If we are able to subtract our two values away from each other we should be left with just the remaining *rounding error*
					* We can then compare the absolute value of that error to our epsilon and if it is less than said epsilon we can then say that they are equivalent.
								const int EPSILON = 1e-10;
								if( fabs(num1 - num2) <= EPSILON )
									std::count << "Both num1 and num2 are equivalent!";
				</section>
			</div>
		</div>

		<script src="./dist/reveal.js"></script>
		<script src="./plugin/notes/notes.js"></script>
		<script src="./plugin/markdown/markdown.js"></script>
		<script src="./plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
